<context>
# Overview  
ShopIQ is a personal shopping intelligence app to capture, normalize, and compare prices across suppliers so that purchases are consistently cost-effective. It targets a single primary user (the owner) with potential to expand later. The app removes friction by letting the user quickly record offers (price + quantity + units) and computes normalized price-per-unit to identify the cheapest source, powered initially by manual entry and later by scanning/URL ingestion.

Problems addressed:
- I want to save money but lack time to normalize prices across suppliers.
- I can’t remember which supplier had the best price previously.
- I don’t remember what I paid historically; need date-stamped records.
- Risk of overpaying without data; fear of getting ripped off.
- Buying too much can be wasteful; need guidance on quantity decisions.
- Debate over which grocery chain is cheaper lacks objective data.

Who it’s for: Me (single-user) initially, maybe others later.
Primary domain for initial testing: Pool/spa chemicals. Future: groceries and general goods.

# Core Features  
- Quick offer capture
  - Manual entry of item, supplier, total price, quantity, and units (g, kg, ml, L, etc.)
  - Automatic unit conversion to a canonical unit (e.g., g/ml) and price per canonical unit
  - Date-stamped record creation
- Best-price computation
  - For a given inventory item, compute the current cheapest source by normalized price-per-unit
  - Show best current offer and historical trend
- Inventory management
  - Maintain a list of items I care about tracking (Inventory)
  - Link captured offers to inventory items
- Basic quality/notes
  - Optional quality rating and free-form notes per offer and per supplier
- Basic shelf-life awareness (non-blocking)
  - Mark items as shelf-life sensitive and show an informational warning when high-quantity purchases risk expiry
- Foundations for future capture modes (non-MVP)
  - Barcode scanning stub in UI
  - Share-sheet/URL parsing stub in UI

# User Experience  
- Personas
  - Primary: Single user (me) optimizing purchases
- Key flows
  - Add inventory item (name, category, canonical unit, optional shelf-life sensitivity)
  - Capture offer (choose inventory item or quick-create, supplier, total price, quantity, units, date auto-filled)
  - View comparisons (per item: sorted list by price-per-unit; highlight best)
  - Decide where to buy (tap to open supplier URL if present)
  - Optional: add quality rating/notes to remember experience
- UI/UX considerations
  - Ultra-fast capture: minimal required fields; mobile-optimized form; smart defaults for units based on item
  - Display normalized price-per-unit prominently
  - Clear indication of best deal and historical prices
  - Mobile-first form design: touch-friendly, auto-focus progression, mobile keyboard optimization
</context>

<PRD>
# Technical Architecture  
- Client: Expo React Native app (iOS-focused initially; Android optional later)
- Storage (MVP): Local device storage (SQLite via Expo or MMKV). Path to cloud sync later (e.g., Supabase/Firebase or simple REST backend)
- Modules
  - Inventory module
  - Offers module
  - Comparison engine (unit conversion + price-per-unit)
  - Shelf-life advisory (flag-only)
  - Quality/notes

# Mobile Form Optimization Guidelines
## Core Principles
- **Mobile-First Design**: All form optimizations must be designed for touch interfaces and mobile keyboards
- **Ultra-Fast Capture**: Minimize required fields and cognitive load for rapid data entry
- **Smart Defaults**: Auto-populate fields based on context (supplier currency, item units, etc.)
- **Progressive Enhancement**: Start with basic mobile patterns, add advanced features incrementally

## Mobile-Specific Optimizations
### Auto-Focus and Navigation
- **Return Key Progression**: "Next" button moves to next logical field, "Done" submits form
- **Smart Keyboard Types**: Numeric for prices/quantities, email for URLs, default for text
- **Field Ordering**: Logical top-to-bottom flow optimized for thumb navigation
- **Auto-Capitalization**: Appropriate capitalization per field type (none for units, characters for currency)

### Touch Interface Optimizations
- **Touch-Friendly Sizing**: Minimum 44pt touch targets for all interactive elements
- **Swipe Gestures**: Consider swipe-to-navigate between form sections (future enhancement)
- **Voice Input**: Integration with device voice recognition for notes and item names
- **Camera Integration**: Barcode scanning for product identification and quantity entry

### Mobile Keyboard Behavior
- **Keyboard Types**: 
  - `numeric` for prices, quantities, tax rates
  - `email-address` for URLs
  - `default` for text fields
  - `phone-pad` for numeric codes
- **Return Key Types**:
  - `next` for all fields except the last
  - `done` for final field to submit form
- **Auto-Correction**: Disabled for units, codes, and technical terms
- **Auto-Capitalization**: Disabled for units and codes, enabled for names

### Consistent Navigation UX (Critical Best Practice)
- **Universal "Next" Button**: All keyboard types (numeric, URL, default) must show "Next" button when `returnKeyType="next"` is set
- **Platform Compliance**: iOS and Android both respect `returnKeyType` regardless of `keyboardType`
- **User Expectation**: Users expect consistent navigation behavior across all form fields
- **Implementation**: Use `returnKeyType="next"` for all fields except the last, `returnKeyType="done"` for final field
- **Tip Text Accuracy**: Form instructions must accurately describe available navigation (e.g., "Use keyboard 'Next' button to move between fields")
- **Anti-Pattern**: Never mix navigation methods (some fields with "Next", others without) - creates confusion and poor UX

### Performance Considerations
- **Minimal Re-renders**: Use React.memo and useCallback for form components
- **Lazy Loading**: Load picker options on demand
- **Debounced Validation**: Avoid excessive validation calls during typing
- **Optimistic Updates**: Show immediate feedback for auto-populated fields

## Anti-Patterns to Avoid
- **Desktop Keyboard Shortcuts**: Ctrl/Cmd+S, Tab, Arrow keys, Escape - not available on mobile
- **Hover States**: Not applicable to touch interfaces
- **Complex Keyboard Combinations**: Mobile keyboards don't support modifier keys
- **Mouse-Specific Interactions**: Right-click, drag-and-drop, etc.

## Future Mobile Enhancements
- **Barcode Scanning**: Auto-populate product information from barcodes
- **NFC Integration**: Quick supplier identification via NFC tags
- **Location Services**: Auto-detect nearby suppliers
- **Offline-First**: Ensure forms work without internet connection
- **Accessibility**: VoiceOver/TalkBack support for screen readers
- **Haptic Feedback**: Subtle vibrations for form completion and errors

# Data Model (field-by-field with purpose)
Conventions (apply to all entities unless noted):
- id: UUIDv4 string. Stable across local/export/sync to avoid collisions.
- createdAt/updatedAt: ISO timestamp. For history/auditing and deterministic sync.
- deletedAt?: ISO timestamp for soft-delete. Omit in MVP UI but keep for future sync.

Entity: Supplier
- id: Unique supplier identity (UUID).
- name: Canonical supplier/store name used for display and dedupe (e.g., “Amazon.ca”, “Costco Halifax”).
- countryCode: ISO 3166-1 alpha-2 (e.g., “CA”, “US”). For tax/currency rules.
- regionCode?: ISO 3166-2 (e.g., “CA-NS”). Regional pricing/tax nuances.
- storeCode?: Internal short code if multiple outlets within same brand (e.g., “costco-bayerslake”).
- defaultCurrency: ISO 4217 (e.g., “CAD”). Default for offers from this supplier.
- membershipRequired: Boolean; indicates membership affects access/pricing (e.g., Costco).
- membershipType?: Free text (e.g., “Gold Star”). For future amortization decisions.
- shippingPolicy?: JSON object for quick economics (MVP reads but may not compute all):
  - freeShippingThreshold?: Minimum order total to waive shipping (e.g., 35.00).
  - shippingBaseCost?: Base shipping when threshold not met (e.g., 5.99).
  - shippingPerItemCost?: Optional per-item adder where applicable.
  - pickupAvailable?: Whether in-store/locker pickup can zero shipping.
- urlPatterns?: Array of hostname/path hints to map scraped URLs to this supplier.
- notes?: Free text for any operational caveats.
- createdAt/updatedAt/deletedAt?: Timestamps as above.

Entity: InventoryItem
- id: Item identity (UUID).
- name: Human-friendly item name (e.g., “Taylor R-0002 reagent”).
- category?: Optional grouping (e.g., “Pool Chemicals”, “Grocery/Meat”).
- canonicalDimension: One of “mass” | “volume” | “count” | “length” | “area”. Used to choose canonical unit.
- canonicalUnit: The canonical unit for normalization (e.g., “g”, “ml”, “unit”, “m”, “m2”). Selected per item.
- shelfLifeSensitive: Boolean; if true, UI shows expiry-risk warnings on large quantities.
- shelfLifeDays?: Typical shelf life if known; for future modeling.
- usageRatePerDay?: Numeric rate in canonicalUnit/day; captured via simple prompt for future optimization.
- attributes?: JSON map for equivalence (e.g., { concentrationPercent: 10, grade: "food", packCount: 3 }).
- equivalenceFactor?: Optional multiplier for adjusted comparability (1.0 = exact equivalence).
- notes?: Free text.
- createdAt/updatedAt/deletedAt?: Timestamps.

Entity: Offer
- id: Offer identity (UUID).
- inventoryItemId: FK → InventoryItem.id. Which item this offer prices.
- supplierId: FK → Supplier.id. Bind to a normalized supplier record.
- supplierNameSnapshot?: Denormalized supplier name captured at time of entry for display stability.
- supplierUrl?: Product/offer URL for revisit or parsing.
- sourceType: “manual” | “url” | “ocr” | “api”. Provenance; helps debug parsers and data trust.
- sourceUrl?: If captured from a page different than supplierUrl (e.g., listing page).
- rawCapture?: JSON or text blob of raw parsed values before normalization. For audit.
- observedAt: When the price was observed (can differ from capturedAt).
- capturedAt: When the offer was entered into the app (auto-set).
- totalPrice: Total price shown at point of sale for the unit(s) described (numeric).
- currency: ISO 4217 (e.g., “CAD”). Required for accurate comparisons.
- isTaxIncluded: Whether totalPrice already includes sales tax (true for many grocery items).
- taxRate?: If isTaxIncluded=false and known, store applied tax rate (e.g., 0.15). Optional in MVP.
- shippingCost?: Shipping cost applied to this single-offer scenario if freeShippingThreshold not met.
- minOrderAmount?: Supplier minimum order amount for this item or store.
- freeShippingThresholdAtCapture?: Snapshot of the supplier threshold at time of capture.
- shippingIncluded?: Convenience flag indicating whether shipping has been waived (e.g., pickup or threshold met).
- amount: The quantity purchased (numeric).
- amountUnit: Unit as displayed on label (e.g., “ml”, “L”, “g”, “kg”, “tabs”, “count”).
- amountCanonical: Quantity converted into canonicalUnit (computed and stored for speed).
- pricePerCanonicalExclShipping: Computed = pre-tax price per canonical unit (see notes).
- pricePerCanonicalInclShipping: Computed = price per canonical unit including shipping allocations.
- effectivePricePerCanonical: Computed = final normalized comparator including tax/shipping policy choices.
- bundleId?: If part of a multi-item bundle; used to allocate price later.
- qualityRating?: Personal quality rating 1–5. For subjective equivalence adjustments later.
- notes?: Free text.
- photoUri?: Optional image reference captured at time of entry.
- computedByVersion?: String tag of the normalization algorithm version for audit.
- createdAt/updatedAt/deletedAt?: Timestamps.

Entity: UnitConversion (static/reference)
- fromUnit: Unit symbol (e.g., “kg”).
- toUnit: Canonical unit symbol (e.g., “g”).
- factor: Multiplier to convert to canonical (e.g., 1000).
- dimension: “mass” | “volume” | “count” | “length” | “area”. Validates conversions.

Entity: Bundle (future, optional for MVP)
- id: Bundle identity (UUID).
- supplierId: FK → Supplier.id.
- items: Array of { inventoryItemId, amount, unit } describing bundle contents.
- priceAllocationMethod: “equal” | “by-canonical-amount” | “manual”. How to split bundle price across items.

# Computation Notes (normalization & shipping thresholds)
- Canonicalization
  - Convert amount → amountCanonical via UnitConversion based on InventoryItem.canonicalUnit.
- Pre-/post-tax
  - If isTaxIncluded=true → preTax = totalPrice / (1 + taxRate?) when needed; otherwise assume totalPrice is final.
  - Comparisons default to effectivePricePerCanonical (post-tax) for real spend; store both excl/incl for analysis.
- Shipping thresholds (MVP approximation)
  - If freeShippingThresholdAtCapture is set and totalPrice ≥ threshold → shippingCost = 0, shippingIncluded = true.
  - Else if shippingBaseCost known → shippingCost = shippingBaseCost; allocate across amountCanonical.
  - Note: Multi-item cart threshold effects are complex; MVP treats each offer independently and flags when a threshold could waive shipping if combined purchases meet it.
- Effective comparator
  - pricePerCanonicalExclShipping = preTax / amountCanonical
  - pricePerCanonicalInclShipping = (preTax + (shippingCost||0)) / amountCanonical
  - effectivePricePerCanonical = choose inclShipping by default (configurable later).
- Currency
  - MVP: no FX conversion; recommended to stay within one region/currency first. Add FX table later if needed.

# APIs & Integrations (post-MVP)
- Barcode scanning (Expo Camera)
- URL ingestion/parsing for major retailers (pluggable parser interface)
- Cloud sync (auth + backend)
- Parser interface contract (future)
  - Input: url/html blob
  - Output: { supplierId?, supplierUrl, name?, amount, amountUnit, totalPrice, currency, observedAt, rawCapture }

# Development Roadmap  
- MVP
  - Expo RN app with local persistence
  - Inventory CRUD
  - Offer capture form with unit normalization and computed price-per-canonical-unit
  - Per-item comparison view with best-offer highlight
  - Shelf-life sensitivity warning (flag only)
  - Quality rating and notes (optional fields)
  - CSV import/export for Inventory/Offers with UUID assignment and schema version
  - Basic tests: unit tests for conversions/computation; a few E2E tests via Detox
- Future Enhancements
  - Photo capture for offers
  - Barcode scanning for auto quantity/description
  - Share sheet/URL parsing for supplier pages (Amazon and major retailers)
  - Cloud sync with auth; multi-device; backups
  - Advanced shelf-life optimizer (usage forecasting + expiry loss modeling)
  - NLP input for natural language offer entry
  - Supplier reputation and personal satisfaction scoring
  - FX conversion and cross-region support
  - Bundle price allocation methods

# Logical Dependency Chain
1) Foundations: Expo app scaffold, local storage, unit conversion utilities, data models (UUIDs, timestamps)
2) Inventory CRUD and basic list UI
3) Supplier CRUD (minimal) and reference shipping policy fields
4) Offer capture with normalized price-per-unit computation (incl/excl shipping)
5) Per-item comparison view (best price identification)
6) Shelf-life sensitivity warning (flag only)
7) Quality/notes enhancements
8) Hooks for future: barcode scanner & share sheet stubs
9) CSV import/export

# Risks and Mitigations  
- Data capture friction → Optimize form UX, defaults, and sensible canonical units
- Unit conversion errors → Comprehensive unit tests and clear canonicalization rules
- Shelf-life complexity → MVP uses warnings only; defer advanced modeling to later
- Local-only data loss → Provide export/import early; plan cloud sync
- URL parsing variability → Start manual; define pluggable parsers to avoid tight coupling
- Shipping threshold nuance → MVP uses single-offer approximation; document clearly in UI

# Appendix  
- Initial domain CSVs
  - Inventory sample: `ShopIQ Inventory.csv`
  - Offers sample: `ShopIQ Offers.csv`
- Normalization rules
  - Mass: kg→g (×1000); Volume: L→ml (×1000); Count/length/area as declared per item
  - Price-per-canonical = totalPrice / (amount in canonicalUnit), with variants for shipping/tax
- MVP scope boundaries
  - Ignore expiry math beyond a warning flag
  - Single-user, single-device; no cloud sync initially
- Technical Documentation
  - Database schema fixes: `.taskmaster/docs/database-schema-fixes.md` - Common issues and solutions for database table creation and validation
</PRD>

# Task ID: 5
# Title: Inventory CRUD Module
# Status: done
# Dependencies: 4
# Priority: high
# Description: Implement inventory management: add, edit, delete, and list items with canonical units and shelf-life sensitivity.
# Details:
Build React Native screens for inventory CRUD. Use Formik v3+ and Zod for form validation. Store items in SQLite/MMKV. Support optional category, shelf-life, and attributes. Optimize for fast entry and editing.

# Test Strategy:
E2E tests with Detox for all CRUD flows. Unit tests for validation and persistence.

# Subtasks:
## 1. Design and Implement Inventory CRUD Screens [done]
### Dependencies: None
### Description: Create React Native screens for adding, editing, deleting, and listing inventory items. Ensure UI supports fast entry and editing, and includes fields for canonical units, optional category, shelf-life, and custom attributes.
### Details:
Use Formik v3+ for form state management and Zod for schema validation. Layout should optimize for mobile usability and quick data entry. Include UI elements for all CRUD operations and display inventory in a searchable, filterable list.
<info added on 2025-09-04T14:25:30.513Z>
Auto-detect canonical dimension from unit selection by removing the canonicalDimension field from user input and using getUnitDimension(unit) to infer the dimension automatically, ensuring only valid unit/dimension combinations and reducing user decisions. Implement an autocomplete search field for canonical unit selection, grouping results by dimension and showing recently used units first, with real-time validation via isSupportedUnit() and fuzzy matching for unit aliases. Prioritize required fields (item name with autocomplete, canonical unit with autocomplete and auto-dimension detection) for ultra-fast capture, with optional fields (category, shelf-life sensitivity, advanced options) revealed progressively. Design the UI to support future NLP parsing (e.g., single text input like "2.5 kg") while currently using separate quantity and unit fields, and provide visual confirmation of detected dimension (e.g., "kg → mass dimension"). Include error handling with suggested alternatives for unsupported units and ensure technical integration is ready for AI parsing using validateAndConvert() logic.
</info added on 2025-09-04T14:25:30.513Z>
<info added on 2025-09-04T17:06:15.001Z>
ARCHITECTURAL DECISIONS FINALIZED:

Navigation Framework: Use Expo Router for file-based navigation. Set up the /app directory structure and implement stack navigation for the List → Create/Edit → Details flow.

Category Management: Implement auto-suggest for categories based on existing inventory items. Allow new category creation with duplicate prevention via normalization (trim, lowercase comparison).

List Performance: Render inventory lists using FlatList for scalability. Integrate SQLite-backed search queries through the repository pattern, optimizing queries with indexing for name and category.

Search Implementation: Add an inline search bar at the top of the inventory list screen. Enable real-time, debounced search across item name, category, and notes using SQLite FTS for efficient performance as the list grows.

Edit/Create Flow: Use a unified form component for both create and edit operations, determined by route parameter (/inventory/form vs /inventory/form/[id]). Share validation logic and form state, and pre-populate fields when editing.

Soft Delete Strategy: Hide soft-deleted items from the main list and provide a "Recently Deleted" section/screen with restore functionality. Repository queries should filter out deleted items by default.

Implementation Order:
1. Set up Expo Router and basic screen structure
2. Create unified form component with auto-detection
3. Implement list screen with search functionality
4. Add soft delete handling and recently deleted section
</info added on 2025-09-04T17:06:15.001Z>
<info added on 2025-09-04T17:11:17.594Z>
DESIGN DECISIONS FINALIZED:

Visual Priority Hierarchy: Item name (primary) > canonical unit (secondary) > category (tertiary) > metadata (quaternary)
Design Personality: Utilitarian/developer-tool aesthetic focused on data efficiency over decoration
Error Handling: Immediate validation to prevent errors rather than fix them after occurrence

Typography Scale:
- Item Name: 18pt bold (primary scanning target)
- Canonical Unit: 16pt medium with dimension indicator (critical for price comparison)
- Category: 14pt medium gray (organizational context)
- Metadata: 12pt light gray (dates, notes preview)

Color Strategy - Business Logic Focused:
- Extend existing success/error pattern
- Add best-price indicators, shelf-life warnings, dimension confirmations
- Maintain minimal palette focused on functional meaning over decoration

Interaction Patterns:
- Bottom sheet autocomplete for unit selection (native mobile feel)
- Immediate validation feedback during input
- Adaptive information density (expandable list items)
- Thumb-friendly touch targets and navigation
</info added on 2025-09-04T17:11:17.594Z>
<info added on 2025-09-04T17:13:14.833Z>
Adopt an Apple-like consumer design language throughout all inventory CRUD screens. Use iOS-native typography styles (Large Title, Headline, Body, Caption) and system colors for all UI elements. Apply subtle shadows, rounded corners, and depth to containers and controls. Implement familiar iOS interaction patterns such as swipe actions on list items, pull-to-refresh, and smooth, context-aware animations and transitions. Structure forms and lists with progressive disclosure, following iOS conventions for information hierarchy and clarity. Ensure all input fields and controls use native iOS form patterns, with accessibility and Dynamic Type support for text scaling. Prioritize delight and ease of use for non-technical users, moving away from utilitarian or developer-focused aesthetics.
</info added on 2025-09-04T17:13:14.833Z>
<info added on 2025-09-04T17:18:14.141Z>
FINAL APPLE-STYLE DESIGN SPECIFICATIONS:

Color Strategy:
- Use iOS system semantic colors throughout the UI, including iOS Green for best price indicators, iOS Orange for shelf-life warnings, and system colors for category grouping. No custom color palette should be introduced.

Navigation Pattern:
- Implement iOS Reminders-style navigation with swipe gestures on list items: swipe right for Edit (primary action), swipe left for Delete (secondary action), tap for quick preview or immediate action, and long press for additional context menu actions.

Information Density:
- Structure list items for efficient, iOS Settings-style information density: display item name and canonical unit inline as the primary row, with category and metadata as a subtitle. Ensure the layout remains clean and balanced, maximizing visible information without clutter.

Input Experience:
- For unit autocomplete, present a full-screen iOS search interface with native keyboard, search optimizations, and familiar iOS search patterns and animations. Include clear and cancel actions, and ensure navigation follows iOS conventions.

Visual Delight:
- Apply clean lines, standard iOS animations, and smooth transitions using iOS timing curves. Prioritize content over decoration, with subtle visual feedback and haptic feedback for key interactions (selection, validation). All visual states and feedback should use system-standard patterns for consistency and accessibility.
</info added on 2025-09-04T17:18:14.141Z>
<info added on 2025-09-04T17:38:28.470Z>
MAJOR PROGRESS COMPLETED:

- Expo Router navigation structure is fully implemented with iOS-style stack navigation and headers.
- Inventory list screen uses FlatList for scalable rendering, supports real-time debounced search, pull-to-refresh, swipe actions for Edit/Delete, and integrates repository queries with error handling.
- Unified form component is complete with Formik v3+, Zod validation, auto-dimension detection from unit selection, unit autocomplete modal grouped by dimensions, progressive disclosure of fields, and Apple-style design using system colors and typography.
- Edit screen supports dynamic route parameters, pre-populated form data, update and delete operations, and confirmation alerts.
- All CRUD operations are functional, with navigation, form validation, unit conversion, and Apple-style UI patterns in place.
- Technical highlights include iOS Reminders-style navigation, system semantic colors for indicators, dimension confirmation feedback, strict TypeScript typing, repository pattern integration, and accessibility-ready design.
- Remaining tasks: implement Recently Deleted section and complete end-to-end flow testing.
</info added on 2025-09-04T17:38:28.470Z>
<info added on 2025-09-04T19:39:59.098Z>
CRITICAL DATABASE FIX COMPLETED:

The root cause of previous INSERT failures was a column/value mismatch in InventoryItemRepository.mapEntityToRow(), where undefined fields like category were omitted from the SQL statement, causing value misalignment. This has been resolved by switching from || to ?? (nullish coalescing), ensuring all columns are included and undefined properties are set to null. As a result, all database columns are now properly mapped, and the full CRUD flow is functional: users can add, edit, and delete inventory items with correct persistence and validation. End-to-end item creation, editing, and listing are now operational, and the system is ready for comprehensive testing. The only remaining optional feature is the "Recently Deleted" section.
</info added on 2025-09-04T19:39:59.098Z>

## 2. Integrate Local Persistence with SQLite/MMKV [done]
### Dependencies: 5.1
### Description: Implement data storage for inventory items using SQLite and/or MMKV, ensuring all CRUD operations persist data locally and efficiently.
### Details:
Abstract storage logic to support both SQLite and MMKV. Ensure all item fields (including optional ones) are stored and retrieved correctly. Implement data migration and handle edge cases such as schema changes or data corruption.
<info added on 2025-09-04T21:38:19.465Z>
✅ Implementation Progress Update:

Home Screen Text Update: Updated all references from "grocery" to "household" to reflect broader product coverage.

Repository Factory Consistency: Ensured all form and edit screens use the singleton RepositoryFactory.getInstance() for consistent repository access.

Web Persistence Enhancement: Added a comprehensive web debugging panel for localStorage persistence, including data count display, one-click data clearing, and visual confirmation of storage operations (development-only).

Code Integration: Integrated all CRUD operations with both SQLite (native) and localStorage (web fallback).

Current State:

- SQLite database configured with comprehensive schemas.
- Repository pattern implemented with BaseRepository and InventoryItemRepository.
- Web fallback using localStorage with full CRUD operation mocking.
- Form validation and error handling in place.
- Factory pattern ensures a single database connection.
- Migration system implemented for future schema changes.

Web Testing Capabilities Added:

- Debug panel for localStorage data count.
- One-click data clearing for testing.
- Visual confirmation of storage operations.
- Panel is development-only and hidden in production.

Ready for Testing:

The persistence layer is fully functional and ready for comprehensive browser testing. All CRUD operations (Create, Read, Update, Delete) are working with proper data persistence.
</info added on 2025-09-04T21:38:19.465Z>

## 3. Implement Validation and Shelf-Life Sensitivity Logic [done]
### Dependencies: 5.1, 5.2
### Description: Apply Zod validation schemas to all inventory forms and add logic to handle shelf-life sensitive items, including warnings or flags for items at risk of expiry.
### Details:
Define Zod schemas for all item fields, including canonical units and optional attributes. Implement validation feedback in the UI. Add logic to detect shelf-life sensitivity and display appropriate warnings or banners during item entry and editing.
<info added on 2025-09-05T01:55:52.938Z>
Analysis of current implementation reveals that while comprehensive Zod schemas exist and cover all necessary validation logic (including shelf-life and canonical units), the inventory form currently uses only a basic schema and lacks advanced validation feedback, shelf-life sensitivity warnings, and expiry-risk alerts. To address these gaps, the following implementation steps are required: create a form-specific validation schema (excluding BaseEntity fields), integrate shelf-life warning banners/alerts into the form UI, enhance validation feedback with improved error display, add logic for shelf-life risk warnings during item entry, and develop reusable validation utilities for form validation.
</info added on 2025-09-05T01:55:52.938Z>
<info added on 2025-09-05T02:00:18.410Z>
Implementation complete. The inventory form now features comprehensive, form-specific validation using `InventoryItemFormSchema`, including cross-field and unit compatibility checks, with smart contextual error messages. Shelf-life risk is dynamically assessed via `calculateShelfLifeRisk()`, providing four risk levels and contextual waste warnings. UI enhancements include a color-coded `ShelfLifeWarning` component, improved error and warning displays, and Apple-inspired styling. All fields support real-time validation feedback, visual error states, and actionable recommendations. Validation is fully integrated with Formik for immediate feedback, with errors and warnings shown at both field and form levels without blocking submission. The solution is type-safe, lint-free, and uses reusable validation utilities consistent with the codebase.
</info added on 2025-09-05T02:00:18.410Z>


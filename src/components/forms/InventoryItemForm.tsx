import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Switch,
  Alert,
} from 'react-native';
import { Formik, FormikProps } from 'formik';
import { colors } from '../../constants/colors';
import { InventoryItemSchema } from '../../storage/validation/schemas';
import { ValidatedInventoryItem } from '../../storage/validation/schemas';
import { InventoryItem } from '../../storage/repositories/InventoryItemRepository';
import {
  getSupportedUnitsForDimension,
  getUnitDimension,
  isSupportedUnit,
  getSupportedDimensions,
} from '../../storage/utils/canonical-units';
import { CanonicalDimension } from '../../storage/types';

interface InventoryItemFormProps {
  initialValues?: Partial<InventoryItem>;
  onSubmit: (values: ValidatedInventoryItem) => Promise<void>;
  onCancel: () => void;
  submitButtonText?: string;
}

interface FormValues {
  name: string;
  category: string;
  canonicalUnit: string;
  shelfLifeSensitive: boolean;
  shelfLifeDays: string;
  usageRatePerDay: string;
  notes: string;
}

export const InventoryItemForm: React.FC<InventoryItemFormProps> = ({
  initialValues,
  onSubmit,
  onCancel,
  submitButtonText = 'Save Item',
}) => {
  const [detectedDimension, setDetectedDimension] =
    useState<CanonicalDimension | null>(null);
  const [unitSuggestions, setUnitSuggestions] = useState<string[]>([]);
  const [showUnitSuggestions, setShowUnitSuggestions] = useState(false);
  const [availableUnits, setAvailableUnits] = useState<
    Record<CanonicalDimension, string[]>
  >({} as Record<CanonicalDimension, string[]>);

  useEffect(() => {
    // Load all available units by dimension
    const unitsByDimension: Record<CanonicalDimension, string[]> = {} as Record<
      CanonicalDimension,
      string[]
    >;
    const dimensions = getSupportedDimensions();

    dimensions.forEach(dimension => {
      unitsByDimension[dimension] = getSupportedUnitsForDimension(dimension);
    });

    setAvailableUnits(unitsByDimension);
  }, []);

  const getInitialFormValues = (): FormValues => ({
    name: initialValues?.name || '',
    category: initialValues?.category || '',
    canonicalUnit: initialValues?.canonical_unit || '',
    shelfLifeSensitive: initialValues?.shelf_life_sensitive || false,
    shelfLifeDays: initialValues?.shelf_life_days?.toString() || '',
    usageRatePerDay: initialValues?.usage_rate_per_day?.toString() || '',
    notes: initialValues?.notes || '',
  });

  const handleUnitChange = (
    unit: string,
    setFieldValue: (field: string, value: string) => void
  ) => {
    setFieldValue('canonicalUnit', unit);

    // Auto-detect dimension from unit
    const dimension = getUnitDimension(unit);
    setDetectedDimension(dimension || null);

    // Show suggestions for the detected dimension
    if (dimension) {
      setUnitSuggestions(availableUnits[dimension] || []);
      setShowUnitSuggestions(true);
    } else {
      setShowUnitSuggestions(false);
    }
  };

  const handleUnitInputFocus = (
    _setFieldValue: (field: string, value: string) => void
  ) => {
    // Show all available units when focusing
    const allUnits = Object.values(availableUnits).flat();
    setUnitSuggestions(allUnits);
    setShowUnitSuggestions(true);
  };

  const validateForm = (values: FormValues) => {
    const errors: Partial<FormValues> = {};

    if (!values.name.trim()) {
      errors.name = 'Item name is required';
    }

    if (!values.canonicalUnit.trim()) {
      errors.canonicalUnit = 'Canonical unit is required';
    } else if (!isSupportedUnit(values.canonicalUnit)) {
      errors.canonicalUnit =
        'Unsupported unit. Please select from suggestions.';
    }

    if (
      values.shelfLifeDays &&
      (isNaN(Number(values.shelfLifeDays)) || Number(values.shelfLifeDays) <= 0)
    ) {
      errors.shelfLifeDays = 'Shelf life must be a positive number';
    }

    if (
      values.usageRatePerDay &&
      (isNaN(Number(values.usageRatePerDay)) ||
        Number(values.usageRatePerDay) < 0)
    ) {
      errors.usageRatePerDay = 'Usage rate must be a non-negative number';
    }

    return errors;
  };

  const handleSubmit = async (
    values: FormValues,
    { setSubmitting }: { setSubmitting: (isSubmitting: boolean) => void }
  ) => {
    try {
      // Convert form values to validated inventory item
      const inventoryItemData = {
        id: initialValues?.id || '', // Will be generated by repository if empty
        name: values.name.trim(),
        category: values.category.trim() || undefined,
        canonicalDimension: detectedDimension!,
        canonicalUnit: values.canonicalUnit.trim(),
        shelfLifeSensitive: values.shelfLifeSensitive,
        shelfLifeDays: values.shelfLifeDays
          ? Number(values.shelfLifeDays)
          : undefined,
        usageRatePerDay: values.usageRatePerDay
          ? Number(values.usageRatePerDay)
          : undefined,
        notes: values.notes.trim() || undefined,
        created_at: initialValues?.created_at || new Date().toISOString(),
        updated_at: new Date().toISOString(),
        deleted_at: undefined,
      };

      // Validate with Zod schema
      const validationResult = InventoryItemSchema.safeParse(inventoryItemData);
      if (!validationResult.success) {
        const errorMessages = validationResult.error.errors
          .map(err => err.message)
          .join(', ');
        Alert.alert('Validation Error', errorMessages);
        return;
      }

      await onSubmit(validationResult.data);
    } catch {
      // Error handling is done via Alert.alert
      Alert.alert('Error', 'Failed to save inventory item');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Formik
      initialValues={getInitialFormValues()}
      validate={validateForm}
      onSubmit={handleSubmit}
    >
      {({
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        setFieldValue,
        handleSubmit,
        isSubmitting,
      }: FormikProps<FormValues>) => (
        <ScrollView
          style={styles.container}
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.form}>
            {/* Item Name */}
            <View style={styles.fieldContainer}>
              <Text style={styles.label}>Item Name *</Text>
              <TextInput
                style={[
                  styles.input,
                  errors.name && touched.name && styles.inputError,
                ]}
                value={values.name}
                onChangeText={handleChange('name')}
                onBlur={handleBlur('name')}
                placeholder="Enter item name"
                placeholderTextColor={colors.grayText}
              />
              {errors.name && touched.name && (
                <Text style={styles.errorText}>{errors.name}</Text>
              )}
            </View>

            {/* Category */}
            <View style={styles.fieldContainer}>
              <Text style={styles.label}>Category</Text>
              <TextInput
                style={styles.input}
                value={values.category}
                onChangeText={handleChange('category')}
                onBlur={handleBlur('category')}
                placeholder="Enter category (optional)"
                placeholderTextColor={colors.grayText}
              />
            </View>

            {/* Canonical Unit with Auto-detection */}
            <View style={styles.fieldContainer}>
              <Text style={styles.label}>Canonical Unit *</Text>
              <TextInput
                style={[
                  styles.input,
                  errors.canonicalUnit &&
                    touched.canonicalUnit &&
                    styles.inputError,
                ]}
                value={values.canonicalUnit}
                onChangeText={text => handleUnitChange(text, setFieldValue)}
                onBlur={handleBlur('canonicalUnit')}
                onFocus={() => handleUnitInputFocus(setFieldValue)}
                placeholder="Enter unit (e.g., kg, ml, unit)"
                placeholderTextColor={colors.grayText}
                autoCapitalize="none"
              />
              {detectedDimension && (
                <Text style={styles.dimensionText}>
                  Detected dimension: {detectedDimension}
                </Text>
              )}
              {errors.canonicalUnit && touched.canonicalUnit && (
                <Text style={styles.errorText}>{errors.canonicalUnit}</Text>
              )}

              {/* Unit Suggestions */}
              {showUnitSuggestions && unitSuggestions.length > 0 && (
                <View style={styles.suggestionsContainer}>
                  {unitSuggestions.slice(0, 10).map(unit => (
                    <TouchableOpacity
                      key={unit}
                      style={styles.suggestionItem}
                      onPress={() => {
                        handleUnitChange(unit, setFieldValue);
                        setShowUnitSuggestions(false);
                      }}
                    >
                      <Text style={styles.suggestionText}>{unit}</Text>
                    </TouchableOpacity>
                  ))}
                </View>
              )}
            </View>

            {/* Shelf Life Sensitivity */}
            <View style={styles.fieldContainer}>
              <View style={styles.switchContainer}>
                <Text style={styles.label}>Shelf-life Sensitive</Text>
                <Switch
                  value={values.shelfLifeSensitive}
                  onValueChange={value =>
                    setFieldValue('shelfLifeSensitive', value)
                  }
                  trackColor={{ false: colors.lightGray, true: colors.primary }}
                  thumbColor={
                    values.shelfLifeSensitive ? colors.white : colors.grayText
                  }
                />
              </View>
            </View>

            {/* Shelf Life Days (conditional) */}
            {values.shelfLifeSensitive && (
              <View style={styles.fieldContainer}>
                <Text style={styles.label}>Shelf Life (days)</Text>
                <TextInput
                  style={[
                    styles.input,
                    errors.shelfLifeDays &&
                      touched.shelfLifeDays &&
                      styles.inputError,
                  ]}
                  value={values.shelfLifeDays}
                  onChangeText={handleChange('shelfLifeDays')}
                  onBlur={handleBlur('shelfLifeDays')}
                  placeholder="Enter shelf life in days"
                  placeholderTextColor={colors.grayText}
                  keyboardType="numeric"
                />
                {errors.shelfLifeDays && touched.shelfLifeDays && (
                  <Text style={styles.errorText}>{errors.shelfLifeDays}</Text>
                )}
              </View>
            )}

            {/* Usage Rate Per Day */}
            <View style={styles.fieldContainer}>
              <Text style={styles.label}>Usage Rate (per day)</Text>
              <TextInput
                style={[
                  styles.input,
                  errors.usageRatePerDay &&
                    touched.usageRatePerDay &&
                    styles.inputError,
                ]}
                value={values.usageRatePerDay}
                onChangeText={handleChange('usageRatePerDay')}
                onBlur={handleBlur('usageRatePerDay')}
                placeholder="Enter usage rate (optional)"
                placeholderTextColor={colors.grayText}
                keyboardType="numeric"
              />
              {errors.usageRatePerDay && touched.usageRatePerDay && (
                <Text style={styles.errorText}>{errors.usageRatePerDay}</Text>
              )}
            </View>

            {/* Notes */}
            <View style={styles.fieldContainer}>
              <Text style={styles.label}>Notes</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={values.notes}
                onChangeText={handleChange('notes')}
                onBlur={handleBlur('notes')}
                placeholder="Enter notes (optional)"
                placeholderTextColor={colors.grayText}
                multiline
                numberOfLines={3}
                textAlignVertical="top"
              />
            </View>

            {/* Action Buttons */}
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={onCancel}
                disabled={isSubmitting}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.submitButton,
                  isSubmitting && styles.submitButtonDisabled,
                ]}
                onPress={() => handleSubmit()}
                disabled={isSubmitting}
              >
                <Text style={styles.submitButtonText}>
                  {isSubmitting ? 'Saving...' : submitButtonText}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      )}
    </Formik>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.white,
  },
  scrollContent: {
    flexGrow: 1,
    paddingBottom: 40, // Extra padding to ensure buttons are visible
  },
  form: {
    padding: 20,
  },
  fieldContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.darkText,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: colors.lightGray,
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    color: colors.darkText,
    backgroundColor: colors.white,
  },
  inputError: {
    borderColor: colors.error,
  },
  textArea: {
    height: 80,
  },
  dimensionText: {
    fontSize: 14,
    color: colors.primary,
    marginTop: 4,
    fontWeight: '500',
  },
  errorText: {
    fontSize: 14,
    color: colors.error,
    marginTop: 4,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  suggestionsContainer: {
    marginTop: 8,
    backgroundColor: colors.white,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: colors.lightGray,
    maxHeight: 200,
  },
  suggestionItem: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: colors.lightGray,
  },
  suggestionText: {
    fontSize: 16,
    color: colors.darkText,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 40,
    marginBottom: 30,
    paddingHorizontal: 0,
    backgroundColor: colors.white, // Ensure background visibility
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: colors.lightGray,
    marginRight: 10,
    alignItems: 'center',
    backgroundColor: colors.white,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.darkText,
  },
  submitButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 12,
    backgroundColor: colors.primary,
    marginLeft: 10,
    alignItems: 'center',
    shadowColor: colors.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 3,
  },
  submitButtonDisabled: {
    backgroundColor: colors.lightGray,
    shadowOpacity: 0.1,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.white,
  },
});

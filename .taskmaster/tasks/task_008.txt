# Task ID: 8
# Title: Comparison Engine Implementation
# Status: done
# Dependencies: 7
# Priority: high
# Description: Develop engine to compute best price-per-unit for each inventory item, including historical trend and effective comparator.
# Details:
Implement logic for price-per-canonical-unit (excl/incl shipping/tax). Use SQLite queries for sorting and filtering. Highlight best offer and show historical prices. Support configuration for comparator selection.

# Test Strategy:
Unit tests for comparator logic. E2E tests for comparison view accuracy.

# Subtasks:
## 1. Define Comparator Logic and Configuration [done]
### Dependencies: None
### Description: Specify the logic for comparing inventory items, including configuration options for selecting different comparators (e.g., price-per-unit, total price, historical trend). Design a flexible interface to allow runtime comparator selection.
### Details:
Document comparator strategies and configuration schema. Ensure extensibility for future comparator types. Validate with stakeholders.
<info added on 2025-09-06T03:37:47.474Z>
Current System Analysis

Existing Comparison Infrastructure:
- The system currently uses the `effective_price_per_canonical` field for offer comparison, with sorting handled by the `findByInventoryItemSortedByPrice()` method.
- Three price metrics are computed and stored: `price_per_canonical_excl_shipping`, `price_per_canonical_incl_shipping`, and `effective_price_per_canonical` (which defaults to including shipping).
- Comparison is limited to a single strategy (effective price per canonical unit), with no runtime configuration for alternative methods.

Current Limitations:
- Only one comparison strategy is supported.
- No runtime configurability for different comparison methods.
- No integration of quality ratings, historical trends, or other comparison factors.
- Pricing comparison is hard-coded to include shipping.

Key Data Available for Comparison:
- Price metrics (excluding/including shipping, effective)
- Quality ratings (1â€“5 scale)
- Observed timestamps for historical analysis
- Supplier information
- Currency and tax details
- Bundle information
- Equivalence factors from inventory items

Next Steps:
Design a flexible comparator interface that supports runtime selection of comparison strategies, while maintaining backward compatibility with the current `effective_price_per_canonical` approach.
</info added on 2025-09-06T03:37:47.474Z>
<info added on 2025-09-06T03:40:27.055Z>
Core comparator logic and configuration schema have been fully designed and implemented. The architecture now includes a unified Comparator interface, a base abstract class for shared logic, and multiple concrete comparator strategies (including price-per-canonical, total price, price-per-unit, and quality-adjusted price). The Comparison Engine supports runtime strategy selection, caching, parallel processing, and comprehensive validation. The configuration schema enables flexible, context-specific comparator selection and composite strategies. Extensibility is ensured via the strategy and factory patterns, with plugin support for future custom comparators. All features maintain backward compatibility with the legacy effective price-per-canonical approach. Usage examples and validation patterns have been documented, and the design has been reviewed with stakeholders.
</info added on 2025-09-06T03:40:27.055Z>

## 2. Implement Price-per-Canonical-Unit Calculation [done]
### Dependencies: 8.1
### Description: Develop logic to compute price-per-canonical-unit for each offer, supporting both exclusion and inclusion of shipping and tax. Ensure calculations are accurate and handle edge cases (e.g., missing data, zero units).
### Details:
Implement calculation functions in the comparison engine. Integrate with data models for offers and inventory items. Write unit tests for calculation accuracy.
<info added on 2025-09-06T03:44:35.734Z>
Begin implementation of dedicated price calculation utilities to support price-per-canonical-unit logic, both excluding and including shipping/tax. Enhance existing comparators with robust calculation functions that handle edge cases such as missing data, zero units, and invalid conversions. Integrate these utilities with the comparison engine and ensure comprehensive error handling and validation. Write unit tests to verify calculation accuracy across all scenarios.
</info added on 2025-09-06T03:44:35.734Z>
<info added on 2025-09-06T03:52:23.488Z>
Successfully implemented comprehensive price calculation utilities (priceCalculations.ts) supporting price-per-canonical-unit logic with options for excluding/including shipping and tax, effective price usage, currency conversion, and equivalence factors. Robust edge case handling covers zero units, missing data, invalid conversions, NaN/Infinity values, unit conversion failures, and confidence scoring based on data completeness. Calculation utilities are fully integrated with the comparison engine, updating PricePerCanonicalComparator and TotalPriceComparator with enhanced error handling and metadata. Comprehensive unit tests (38 total) validate all calculation scenarios, batch operations, edge cases, and utility functions, with all tests passing. The system now delivers accurate, reliable price-per-canonical-unit calculations with thorough error handling and validation.
</info added on 2025-09-06T03:52:23.488Z>

## 3. Develop SQLite Queries for Sorting and Filtering [done]
### Dependencies: 8.2
### Description: Create efficient SQLite queries to sort and filter inventory items and offers based on computed price-per-unit and other comparator criteria. Support dynamic query generation based on user configuration.
### Details:
Optimize queries for performance. Ensure compatibility with local storage schema. Test with large datasets for scalability.
<info added on 2025-09-06T12:55:22.814Z>
Successfully implemented comprehensive SQLite query system for comparison engine sorting and filtering, featuring a dynamic query builder with advanced filtering, sorting, and pagination options; optimized for performance using indexes, window functions, and efficient JOINs; fully integrated with the repository pattern and comparison strategies; and validated with extensive unit and performance testing to ensure scalability, flexibility, and maintainability for large datasets.
</info added on 2025-09-06T12:55:22.814Z>

## 4. Implement Historical Price Tracking [done]
### Dependencies: 8.2
### Description: Design and implement logic to track and store historical prices for each inventory item and offer. Enable retrieval and display of price trends over time.
### Details:
Extend data models and storage schema to support historical data. Implement update and retrieval logic. Provide API for accessing historical trends.

## 5. Highlight Best Offer Logic [done]
### Dependencies: 8.3, 8.4
### Description: Develop logic to identify and highlight the best offer for each inventory item based on the selected comparator and current configuration. Ensure visual and programmatic distinction of the best offer.
### Details:
Integrate with UI highlighting mechanism. Support edge cases (e.g., ties, missing data). Validate with test scenarios.

## 6. Write Unit and End-to-End Tests [done]
### Dependencies: 8.1, 8.2, 8.3, 8.4, 8.5
### Description: Develop comprehensive unit and E2E tests for all comparison engine logic, including comparator selection, price calculations, sorting/filtering, historical tracking, and best offer highlighting.
### Details:
Use Jest for unit tests and Detox for E2E tests. Cover edge cases, error handling, and performance. Integrate with CI pipeline.
<info added on 2025-09-08T15:24:54.190Z>
Update the subtask to focus exclusively on comprehensive unit testing using Jest for all comparison engine logic, including comparator selection, price calculations, sorting/filtering, historical tracking, and best offer highlighting. Ensure all edge cases, error handling, and performance scenarios are thoroughly covered. Remove any requirements related to E2E testing or Detox; E2E testing will be handled in a separate task.
</info added on 2025-09-08T15:24:54.190Z>

